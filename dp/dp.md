## 动态规划入门

![image-20240419165151672](dp1.png)

如果我问你这些数字的总和是多少，我想你会轻松回答我，总和是 $12$ 。

![image-20240419165402564](dp2.png)

如果我要在这些数字的右侧再添加一个 $8$，我想你也能轻松回答我，总和是 $20$。

这可能看起来很基础，但我确信你之所以能轻松回答第二个问题，是因为你已经记住了前 $5$ 个数字（子问题）的总和为 $12$。因此，你只需要计算 $12 + 8$ 的和即可。

![image-20240419171552417](dp3.png)

这其实就是动态规划的核心思想之一：**通过记忆信息来节省时间（计算）**。

## 动态规划

动态规划是一种**通过将（复杂的）原问题分解为一系列（较为简单的、可重叠的）子问题，并利用子问题的解来构建原问题的解**的算法思想。

这些子问题只需解决一次，并在解决后将它们的解决方案（答案）使用数组或哈希表进行存储。当下次遇到相同的子问题时，不需要重新计算其解决方案，只需查找先前计算的解决方案，从而节省计算时间。

> 我们来看一道例题。

### 求斐波那契数组的第 $n$ 项

给定这样一个数列 $1,1,2,3,\dots$

数列的第 $1$ 项为 $1$，第 $2$ 项为 $1$，从第 $3$ 项起，每一项都是前两项的和。请问，该数列的第 $6$ 项的值是多少？

显然，要想知道第 $6$ 项的值，就必须得到第 $4$、$5$ 项的值；而要想得到第 $4、5$ 项的值，就需要分别知道第 $2,3$ 项的值，第 $3,4$ 项的值，以此类推。在计算后面的项之前，总是需要先计算出前面的数字。

若用一棵树来表示每一项的依赖关系，则树的形状大致如下（其中 $F(i)$ 表示数列第 $i$ 项的值）：

![image-20240421130928209](dp4.png)

对此，不妨让我们使用递归的方法来实现每一项的求解。

#### 第一步

定义递归函数 `F`，其传入一个参数 $n$，并且返回数列第 $n$ 项的值。

```cpp
// 伪代码
// 函数名为 F
// 函数需要传入一个参数 n
// 函数的返回值为数列第 n 项的值
F(参数 n){
  return 第 n 项的值
}
```

为了方便演示，我们接下来将以 C++ 代码为例。

我们知道，数列的第 $1$ 项和第 $2$ 项的值均为 $1$，因此在函数中，我们可以进行一个特判，即：

> 直接返回结果，无需计算。

```cpp
int F(int n){
  if(n == 1 || n == 2) return 1;
}
```

而除了第 $1$ 项和第 $2$ 项的值为 $1$ 外，其余每项，均为前两项的和。

那前两项的和分别是多少呢？简单，根据 `F()` 函数的定义，我们可知，前两项的和分别是 `F(n-1)` 和 `F(n-2)`。至于 `F(n-1)` 和 `F(n-2)` 的值究竟是多少，我们无需关心，程序会自动帮我们计算。

因此，我们有：

```cpp
int F(int n){
  if(n == 1 || n == 2) return 1;
  else return F(n - 1) + F(n - 2);
}
```

在 `sublime` 中调用 $6$ 次函数，并分别传入参数 $1,2,3,4,5,6$，可以得到计算结果分别为 $1,1,2,3,5,8$。和我们预期的一样。

但如果此时我传入的参数不再是 $1\sim6$，而是一个较大的参数，比如 $46$。再次运行程序，会发现结果并不会马上被计算出来。这是因为同一个子问题在递归过程中被重复计算了多次。例如，要计算 `F(6)`，我们需要计算 `F(5)` 和 `F(4)`，但在计算 `F(5)` 时，我们又需要重新计算 `F(4)`，如此这般，`F(4)`会被计算多次（`F(3)`、`F(2)`、`F(1)` 同理），导致计算量呈指数级增长。这正是递归方法的低效所在。

我们可以给函数添加一个计数器 $cnt$，在每次调用函数时使其值 $+1$，并在程序结束后打印sh $cnt$ 的值，以此来获取程序的计算量：

```cpp
long long cnt = 0;
int F(int n){
  cnt ++ ;
  if(n == 1 || n == 2) return 1;
  else return F(n - 1) + F(n - 2);
}
```

可以看到，函数的计算量接近 $37$ 亿（$3672623805$），十分庞大。

为了解决这个问题，我们需要引入动态规划的第二个核心思想：**优化重叠子问题**。 

#### 第二步

 既然 `F(4)` 会被重复计算多次，那么不妨让我们将 `F(4)` 记录下来，以避免重复计算。

我们可以定义一个足够大的数组 $dp[]$，并将其抽象为若干个桶。对于 `F(i)` 的计算结果，我们将其存储在第 $i$ 个桶中。

起初，先将数组中所有元素的值初始化为 $0$ 或 $-1$，表示桶中还未存储到任何计算结果。

![image-20240520174015427](dp5.png)

当我们在计算 `F(i)` 并得到结果后，便可将结果保存到 $dp[i]$ 中。如果后续过程需要使用到 `F(i)` 的值，我们只需直接从第 $i$ 个桶中取用即可。

基于上述思路，我们可以修改 `F` 函数如下： 

```cpp
int dp[1000];
int F(int n){
  if(n == 1 || n == 2) return 1; // 第 1 项和第 2 项的值是已知的
  if(dp[n] != 0) return dp[n]; // 如果数组 dp 中已经存储了 F(n) 的值，则直接返回 dp[n]
  dp[n] = F(n - 1) + F(n - 2); // 计算F(n)，并保存在数组 dp 中
  return dp[n]; // 返回计算后的值
}
```

现在，如果我们再次调用 `F(46)`，程序将会快速返回结果。

这种存储计算结果的方法也被称为“记忆化”（memoization），它是动态规划的一种实现形式。因为每个子问题只被解决一次，因此原先指数级的时间复杂度可降低至线性级。

再次通过计数器 $cnt$ 去获取程序的计算量，可以看到现在仅有 $89$。

#### 第三步

尽管记忆化递归提高了效率，但递归本身还是有一定的内存开销，且递归的层次过深还可能导致栈溢出。

因此，我们可以进一步优化，改用迭代的方式来实现。

```cpp
int F(int n){
  int dp[1000] = {0}; // 初始化数组，所有元素都设为 0
  dp[1] = dp[2] = 1; // 初始化第 1 项和第 2 项的值
  for(int i = 3; i <= n; i++){ // 从第 3 项开始，用迭代的方式计算每一项的值
    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[n]; // 返回第 n 项的值
}
```

这种方式下，我们避免了递归带来的问题，并且保持了动态规划优化重叠子问题的优点。



### 总结

动态规划作为一种重要的算法设计技巧，它可以帮助我们解决许多涉及到优化问题的场景。其核心在于：

- 将问题分解成子问题，找到问题之间的递归关系。
- 储存子问题的解，避免重复计算。
- 自底向上地计算，通常使用迭代方式，以减少递归带来的开销。

通过动态规划，我们可以提高算法效率，节省计算时间。当然，动态规划并不适用于所有的问题，它适用的前提是问题具有重叠子问题和最优子结构的特点。

看到这，相信你已经能够理解动态规划的基本概念，并能够应用它来解决斐波那契数列问题了。当然，在实际应用中，动态规划的问题和解决方案要复杂得多，需要更深入的理解和更多的练习来掌握。