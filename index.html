<!doctype html><html><head><meta charset=UTF-8><title>动态规划 - By candye</title><link rel=stylesheet href=https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://cdn.staticfile.org/prism/1.15.0/themes/prism.min.css><link rel=stylesheet href=https://cdn.staticfile.org/KaTeX/0.10.0-rc.1/katex.min.css><link href=./css/chunk-vendors.4e4765ff.css rel=stylesheet></head><body><div><article id=webslides><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><h1 class="text-landing text-shadow">动态规划</h1><p class=text-intro>By candye</p><p><a href=https://github.com/GsjzTle class="button ghost" target=_blank><i class="fa fa-github"></i> Github</a></p></div></section><section slide class=slide :class="size-60 aligncenter"><div class="wrap size-60 aligncenter" wrap=true><h3>如果我问你这些数组的总和是多少</h3><p><br><img src=./img/dp1.png alt=image-20240419165151672></p><hr><p class="tobuild flipInX">我想你会轻松回答我，总和是 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn><mn>2</mn></mrow><annotation encoding=application/x-tex>12</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">2</span></span></span></span> 。</p></div></section><section slide class=slide :class="size-60 aligncenter"><div class="wrap size-60 aligncenter" wrap=true><h3>如果我要在这些数字的右侧再添加一个 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>8</mn></mrow><annotation encoding=application/x-tex>8</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span></span></span></span></h3><p><br></p><p><img src=./img/dp2.png alt=image-20240419165402564></p><hr><p class="tobuild fliplnX">我想你也能轻松回答我，总和是 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>2</mn><mn>0</mn></mrow><annotation encoding=application/x-tex>20</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathrm">0</span></span></span></span>。</p></div></section><section slide class=slide :class=size-60><div class="wrap size-60" wrap=true><p>这可能看起来很基础，但我确信你之所以能轻松回答第二个问题，是因为你已经记住了前 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>5</mn></mrow><annotation encoding=application/x-tex>5</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span></span></span></span> 个数字（子问题）的总和为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn><mn>2</mn></mrow><annotation encoding=application/x-tex>12</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">2</span></span></span></span>。因此，你只需要计算 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn><mn>2</mn><mo>+</mo><mn>8</mn></mrow><annotation encoding=application/x-tex>12 + 8</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">2</span><span class=mbin>+</span><span class="mord mathrm">8</span></span></span></span> 的和即可。</p><p><img src=./img/dp3.png alt=image-20240419171552417 class="tobuild flipInX"></p><p class="tobuild fliplnX">这其实就是动态规划的核心思想之一：<strong>通过记忆信息来节省时间（减少计算次数）</strong>。</p></div></section><section slide class=slide :class=size-60><div class="wrap size-60" wrap=true><h3 class="text-landing aligncenter">动态规划介绍</h3><hr><p>动态规划是一种<strong>通过将（复杂的）原问题分解为一系列（较为简单的、可重叠的）子问题，并利用子问题的解来构建原问题的解</strong>的算法思想。</p><p>这些子问题只需<strong>解决一次</strong>，并在解决后将它们的解决方案（答案）使用数组或哈希表进行存储。当下次遇到相同的子问题时，不需要重新计算其解决方案，只需查找先前计算的解决方案，从而节省计算时间。</p></div></section><section slide class=slide :class="size-60 aligncenter"><div class="wrap size-60 aligncenter" wrap=true><h3>例题：求斐波那契数组的第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=application/x-tex>n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.43056em;></span><span class="strut bottom" style=height:0.43056em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 项</h3><hr><p class="tobuild fliplnX">给定这样一个数列 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn><mo separator=true>,</mo><mn>1</mn><mo separator=true>,</mo><mn>2</mn><mo separator=true>,</mo><mn>3</mn><mo separator=true>,</mo><mo>⋯</mo></mrow><annotation encoding=application/x-tex>1,1,2,3,\cdots</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.8388800000000001em;vertical-align:-0.19444em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class=mpunct>,</span><span class="mord mathrm">1</span><span class=mpunct>,</span><span class="mord mathrm">2</span><span class=mpunct>,</span><span class="mord mathrm">3</span><span class=mpunct>,</span><span class=minner>⋯</span></span></span></span>。数列的第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=application/x-tex>1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 项为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=application/x-tex>1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>，第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=application/x-tex>2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 项为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=application/x-tex>1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>，从第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>3</mn></mrow><annotation encoding=application/x-tex>3</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span></span></span></span> 项起，每一项都是前两项的和。请问，该数列的第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>6</mn></mrow><annotation encoding=application/x-tex>6</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span></span></span></span> 项的值是多少？</p></div></section><section slide class=slide :class=size-60><div class="wrap size-60" wrap=true><p>显然，要想知道第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>6</mn></mrow><annotation encoding=application/x-tex>6</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span></span></span></span> 项的值，就必须得到第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>4</mn></mrow><annotation encoding=application/x-tex>4</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span></span></span></span>、<span class=katex><span class=katex-mathml><math><semantics><mrow><mn>5</mn></mrow><annotation encoding=application/x-tex>5</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span></span></span></span> 项的值；而要想得到第 4、5 项的值，就需要分别知道第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>2</mn><mo separator=true>,</mo><mn>3</mn></mrow><annotation encoding=application/x-tex>2,3</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.8388800000000001em;vertical-align:-0.19444em;></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class=mpunct>,</span><span class="mord mathrm">3</span></span></span></span> 项的值，第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>3</mn><mo separator=true>,</mo><mn>4</mn></mrow><annotation encoding=application/x-tex>3,4</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.8388800000000001em;vertical-align:-0.19444em;></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class=mpunct>,</span><span class="mord mathrm">4</span></span></span></span> 项的值，以此类推。在计算后面的数字（项）之前，总是需要先计算出前面的数字（项）。</p><p class="tobuild fliplnX">若用一棵树来表示每一个数字（项）的依赖关系，则树的形状将大致如下：</p><p><img src=./img/dp4.png alt=image-20240421130928209 class="tobuild fliplnX"></p><p class="tobuild fliplnX">其中， <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=application/x-tex>F(i)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em;></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em;></span><span class="base textstyle uncramped"><span class="mord mathit" style=margin-right:0.13889em;>F</span><span class=mopen>(</span><span class="mord mathit">i</span><span class=mclose>)</span></span></span></span> 表示数列第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=application/x-tex>i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.65952em;></span><span class="strut bottom" style=height:0.65952em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 项的值。</p></div></section><section slide class=slide :class="size-60 aligncenter"><div class="wrap size-60 aligncenter" wrap=true><p><img src=./img/dp4.png alt=image-20240421130928209></p><hr><p>对此，我们不妨先使用递归的方法来完成每一项的求解。</p></div></section><section slide class=slide :class="build size-90"><div class="wrap build size-90" wrap=true><ol><li>定义递归函数 <code>F</code>，向其传入一个参数 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=application/x-tex>n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.43056em;></span><span class="strut bottom" style=height:0.43056em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span>，并返回数列第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=application/x-tex>n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.43056em;></span><span class="strut bottom" style=height:0.43056em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">n</span></span></span></span> 项的值。</li></ol><pre class=language-java><code class=language-java><span class="token comment">// 伪代码</span>
<span class="token comment">// 函数名为 F</span>
<span class="token comment">// 函数需要传入一个参数 n</span>
<span class="token comment">// 函数的返回值为数列第 n 项的值</span>
<span class="token class-name">F</span><span class="token punctuation">(</span>参数 n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> 第 n 项的值
<span class="token punctuation">}</span>
</code></pre><ol start=2><li>我们知道，数列的第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=application/x-tex>1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 项和第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=application/x-tex>2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 项的值均为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=application/x-tex>1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span>，因此在函数中，我们可以进行一个特判，即：</li></ol><pre class=language-java><code class=language-java><span class="token comment">// 函数名为 F</span>
<span class="token comment">// 函数需要传入一个参数 n</span>
<span class="token comment">// 函数的返回值为数列第 n 项的值</span>
<span class="token keyword">int</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 直接返回结果，无需计算。</span>
<span class="token punctuation">}</span>
</code></pre><ol start=3><li>而除了第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=application/x-tex>1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 项和第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>2</mn></mrow><annotation encoding=application/x-tex>2</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span></span></span></span> 项的值为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn></mrow><annotation encoding=application/x-tex>1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span></span></span></span> 外，其余每项，均为前两项的和。<ul><li>那前两项的和分别是多少呢？简单，根据 <code>F()</code> 函数的定义，我们可知，前两项的和分别是 <code>F(n-1)</code> 和 <code>F(n-2)</code>。至于 <code>F(n-1)</code> 和 <code>F(n-2)</code> 的值究竟是多少，我们无需关心，程序会自动帮我们计算。</li></ul></li></ol><pre class=language-java><code class=language-java><span class="token keyword">int</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></section><section slide class=slide :class="size-60 aligncenter"><div class="wrap size-60 aligncenter" wrap=true><div class="vertical-align grid"><div class=column><pre class=language-java><code class=language-java><span class="token keyword">int</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class=column><p>调用 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>6</mn></mrow><annotation encoding=application/x-tex>6</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span></span></span></span> 次函数 <code>F</code>，并分别传入参数 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn><mo separator=true>,</mo><mn>2</mn><mo separator=true>,</mo><mn>3</mn><mo separator=true>,</mo><mn>4</mn><mo separator=true>,</mo><mn>5</mn><mo separator=true>,</mo><mn>6</mn></mrow><annotation encoding=application/x-tex>1,2,3,4,5,6</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.8388800000000001em;vertical-align:-0.19444em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class=mpunct>,</span><span class="mord mathrm">2</span><span class=mpunct>,</span><span class="mord mathrm">3</span><span class=mpunct>,</span><span class="mord mathrm">4</span><span class=mpunct>,</span><span class="mord mathrm">5</span><span class=mpunct>,</span><span class="mord mathrm">6</span></span></span></span>，可以得到计算结果为：</p><pre class=language-text><code class=language-text>1
1
2
3
5
8
</code></pre><p><i class="fa fa-twitter"></i> 和预期的结果一样。</p></div></div><hr><p class="tobuild fliplnX">到这，我们便完成了递归方法的求解。</p></div></section><section slide class=slide :class=size-70><div class="wrap size-70" wrap=true><h4>但假如，我们传入的参数不再是 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>1</mn><mo>∼</mo><mn>6</mn></mrow><annotation encoding=application/x-tex>1\sim6</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class=mrel>∼</span><span class="mord mathrm">6</span></span></span></span>，而是一个较大的参数 —— <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>4</mn><mn>6</mn></mrow><annotation encoding=application/x-tex>46</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">4</span><span class="mord mathrm">6</span></span></span></span>。</h4><hr><pre class="tobuild fliplnX language-java"><code class=language-java><span class="token keyword">int</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">46</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p class="tobuild fliplnX">再次运行程序，会发现结果无法马上被计算出来。</p><p class="tobuild fliplnX">这是因为同一个子问题在递归过程中被重复计算了多次。例如，要计算 <code>F(6)</code>，我们就需要先计算 <code>F(5)</code> 和 <code>F(4)</code>，但在计算 <code>F(5)</code> 时，我们又需要重新一次计算 <code>F(4)</code>，如此这般，<code>F(4)</code>会被计算多次，导致计算量呈指数级增长（<code>F(3)</code>、<code>F(2)</code>、<code>F(1)</code> 同理）。</p><p class="tobuild fliplnX">这也正是递归法低效的原因。</p></div></section><section slide class=slide :class=size-50><div class="wrap size-50" wrap=true><p>我们可以给函数添加一个计数器 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=application/x-tex>cnt</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.61508em;></span><span class="strut bottom" style=height:0.61508em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span>，在每次调用函数时使 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=application/x-tex>cnt</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.61508em;></span><span class="strut bottom" style=height:0.61508em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span> 的值 <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding=application/x-tex>+1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em;></span><span class="base textstyle uncramped"><span class=mord>+</span><span class="mord mathrm">1</span></span></span></span>，并在程序结束后打印 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=application/x-tex>cnt</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.61508em;></span><span class="strut bottom" style=height:0.61508em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span> 的值，以此来获取程序的计算量（函数的调用次数）。</p><pre class=language-java><code class=language-java><span class="token keyword">long</span> <span class="token keyword">long</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  cnt <span class="token operator">++</span> <span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">46</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cnt = "</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><hr><p class="tobuild fliplnX">输出的 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=application/x-tex>cnt</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.61508em;></span><span class="strut bottom" style=height:0.61508em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span> 的值为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>3</mn><mn>6</mn><mn>7</mn><mn>2</mn><mn>6</mn><mn>2</mn><mn>3</mn><mn>8</mn><mn>0</mn><mn>5</mn></mrow><annotation encoding=application/x-tex>3672623805</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">6</span><span class="mord mathrm">7</span><span class="mord mathrm">2</span><span class="mord mathrm">6</span><span class="mord mathrm">2</span><span class="mord mathrm">3</span><span class="mord mathrm">8</span><span class="mord mathrm">0</span><span class="mord mathrm">5</span></span></span></span>，说明程序的计算量（函数的调用次数）约为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>3</mn><mn>7</mn></mrow><annotation encoding=application/x-tex>37</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">7</span></span></span></span> 亿，十分庞大！</p><p class="tobuild fliplnX">对此，为了减少程序的计算量，我们就需要引入动态规划的第二个核心思想：<strong>优化重叠子问题</strong>。</p></div></section><section slide class=slide :class=size-50><div class="wrap size-50" wrap=true><center style=font-size:40px;font-weight:bold>优化重叠子问题</center><hr><div class=grid><div class=column><p>既然 <code>F(4)</code>、<code>F(3)</code>、<code>F(2)</code>、<code>F(1)</code> 会被重复计算多次，那么不妨让我们将它们记录下来，以避免重复计算。</p><p>我们可以定义一个足够大的数组 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mo>]</mo></mrow><annotation encoding=application/x-tex>dp[]</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em;></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em;></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class=mopen>[</span><span class=mclose>]</span></span></span></span>，并将其抽象为若干个桶。对于 <code>F(i)</code> 的计算结果，将其存储在第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=application/x-tex>i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.65952em;></span><span class="strut bottom" style=height:0.65952em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 个桶中（在调用函数前，先令数组中所有元素的值初始化为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>0</mn></mrow><annotation encoding=application/x-tex>0</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">0</span></span></span></span> 或 <span class=katex><span class=katex-mathml><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=application/x-tex>-1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.72777em;vertical-align:-0.08333em;></span><span class="base textstyle uncramped"><span class=mord>−</span><span class="mord mathrm">1</span></span></span></span>，表示桶中还未存储到任何计算结果）。</p></div><div class=column><p><img src=./img/dp5.png alt=image-20240520174015427></p></div></div><br><blockquote class="tobuild fliplnX"><p>当我们计算出 <code>F(i)</code> 的结果后，便可将结果保存到 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding=application/x-tex>dp[i]</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.75em;></span><span class="strut bottom" style=height:1em;vertical-align:-0.25em;></span><span class="base textstyle uncramped"><span class="mord mathit">d</span><span class="mord mathit">p</span><span class=mopen>[</span><span class="mord mathit">i</span><span class=mclose>]</span></span></span></span> （第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=application/x-tex>i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.65952em;></span><span class="strut bottom" style=height:0.65952em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 个桶）中。如果后续过程需要使用到 <code>F(i)</code> 的值，我们只需直接从第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>i</mi></mrow><annotation encoding=application/x-tex>i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.65952em;></span><span class="strut bottom" style=height:0.65952em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">i</span></span></span></span> 个桶中取用即可。</p></blockquote><p class="tobuild fliplnX">基于上述思路，我们可以对 <code>F</code> 函数进行如下修改：</p><pre class="tobuild fliplnX language-java"><code class=language-java><span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义为全局变量，使数组中所有元素的初始值均为 0</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  cnt <span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 第 1 项和第 2 项的值是已知的</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 如果数组 dp 中已经存储了 F(n) 的值，则直接返回 dp[n]</span>
  dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token class-name">F</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算F(n)，并保存在数组 dp 中</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 返回计算后的值</span>
<span class="token punctuation">}</span>
</code></pre></div></section><section slide class=slide :class=size-40><div class="wrap size-40" wrap=true><p>现在，如果我们再次调用 <code>F(46)</code>，程序将会快速返回结果。</p><pre class=language-java><code class=language-java><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token number">46</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cnt = "</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p class="tobuild fliplnX">通过计数器 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=application/x-tex>cnt</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.61508em;></span><span class="strut bottom" style=height:0.61508em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span> 去获取程序的计算量，可以得到 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=application/x-tex>cnt</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.61508em;></span><span class="strut bottom" style=height:0.61508em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathit">c</span><span class="mord mathit">n</span><span class="mord mathit">t</span></span></span></span> 的值仅有 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>8</mn><mn>9</mn></mrow><annotation encoding=application/x-tex>89</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">8</span><span class="mord mathrm">9</span></span></span></span>。比起原来的 <span class=katex><span class=katex-mathml><math><semantics><mrow><mn>3</mn><mn>7</mn></mrow><annotation encoding=application/x-tex>37</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=strut style=height:0.64444em;></span><span class="strut bottom" style=height:0.64444em;vertical-align:0em;></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">7</span></span></span></span> 亿，极大优化了程序的计算量。</p><p class="tobuild fliplnX">这种存储计算结果的方法也被称为“<strong>记忆化</strong>”（memoization），它是动态规划的一种实现形式。因为每个子问题只被解决一次，因此原先指数级的时间复杂度可降低至线性级。</p></div></section><section slide class=slide :class=size-40><div class="wrap size-40" wrap=true><p>不过，记忆化虽然提高了递归的效率，但递归本身还是有一定的内存开销，且递归的层次过深还可能导致栈溢出。</p><p>因此，我们可以进一步优化，改用迭代的方式来实现。</p><pre class=language-java><code class=language-java><span class="token keyword">int</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 初始化数组，所有元素都设为 0</span>
  dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化第 1 项和第 2 项的值</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 从第 3 项开始，用迭代的方式计算每一项的值</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 返回第 n 项的值</span>
<span class="token punctuation">}</span>
</code></pre><p class="tobuild fliplnX">在这种方式下，我们避免了递归带来的问题，并且保持了动态规划<strong>优化重叠子问题</strong>的特点。</p><blockquote class="tobuild fliplnX"><p>至此，我们完成了动态规划的入门。</p></blockquote></div></section><section slide class=slide :class=size-60><div class="wrap size-60" wrap=true><h2 class="text-landing aligncenter">总结</h2><hr><p>动态规划是一种重要的算法设计思维、技巧，其核心在于：</p><ul><li>将问题分解为子问题，并找出它们之间的递归关系。</li><li>储存子问题的解，避免重复计算。</li><li>自底向上地计算，通常使用迭代方式，以减少递归带来的开销。</li></ul><hr><p>在算法竞赛中，动态规划能够有效地解决优化问题，提高算法的效率，处理各种复杂约束和依赖关系。</p><p>不过，动态规划并不适用于所有的问题，它适用的前提是问题具有<strong>重叠子问题</strong>和<strong>最优子结构</strong>的特点。</p><blockquote class="tobuild fliplnX"><p>看到这里，相信你已经能够理解动态规划的基本概念，并能够应用它来解决斐波那契数列问题了。当然，在实际应用中，动态规划的问题和解决方案要复杂得多，需要更深入的理解和更多的练习来掌握。</p></blockquote></div></section></article></div><script src=https://cdn.staticfile.org/echarts/4.8.0/echarts.min.js></script><script>window.pluginsOptions = {}



    window.webslidesOptions = {}


document.addEventListener('DOMContentLoaded', () => {
    let isPrintMode = false;
    if(~location.search.indexOf('print-pdf')){
        isPrintMode = true;
        WebSlides.registerPlugin('scroll', function(){});
    }
    const wsOptions = {
        loop: false
    };
    if(window.webslidesOptions){
        for (let i in webslidesOptions){
            if(webslidesOptions.hasOwnProperty(i)){
                wsOptions[i] = webslidesOptions[i];
            }
        }
    }
    const ws = new WebSlides(wsOptions)

    window.wsInstance = ws;
    if(isPrintMode){
        ws.slides.forEach(s=>s.show())
    }
}, false)</script><script src=./js/chunk-vendors.js></script><script src=./js/index.js></script></body></html>